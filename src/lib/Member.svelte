import { createHotContext as __vite__createHotContext } from "/@vite/client";import.meta.hot = __vite__createHotContext("/src/lib/Member.svelte");/* C:/Users/Tnix/Desktop/Meower-Svelte-tnixandbloctans-finalfeatures/src/lib/Member.svelte generated by Svelte v3.49.0 */
import {
	SvelteComponentDev,
	add_location,
	append_dev,
	attr_dev,
	component_subscribe,
	create_component,
	destroy_component,
	detach_dev,
	dispatch_dev,
	element,
	globals,
	init,
	insert_dev,
	listen_dev,
	mount_component,
	safe_not_equal,
	set_data_dev,
	space,
	text,
	transition_in,
	transition_out,
	validate_slots,
	validate_store
} from "/node_modules/.vite/deps/svelte_internal.js?v=05521d09";

const { console: console_1 } = globals;
import Container from "/src/lib/Container.svelte";
import PFP from "/src/lib/PFP.svelte";

import {
	profileData,
	profileClicked,
	postClicked,
	user,
	chatid,
	chatOwner,
	ulist,
	mainPage as page,
	modalShown,
	modalPage
} from "/src/lib/stores.js";

import { shiftHeld } from "/src/lib/keyDetect.js";
import * as clm from "/src/lib/clmanager.js";
import { onMount } from "/node_modules/.vite/deps/svelte.js?v=05521d09";
import { apiUrl } from "/src/lib/urls.js";
const file = "C:/Users/Tnix/Desktop/Meower-Svelte-tnixandbloctans-finalfeatures/src/lib/Member.svelte";

// (92:3) {#if $chatOwner === $user.name}
function create_if_block(ctx) {
	let button;

	const block = {
		c: function create() {
			button = element("button");
			attr_dev(button, "class", "circle close s-b-eCKGcAk_zr");
			add_location(button, file, 92, 4, 2274);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(92:3) {#if $chatOwner === $user.name}",
		ctx
	});

	return block;
}

// (89:0) <Container>
function create_default_slot(ctx) {
	let div2;
	let div0;
	let t0;
	let button;
	let pfp;
	let t1;
	let div1;
	let h2;
	let t2;
	let current;
	let mounted;
	let dispose;
	let if_block = /*$chatOwner*/ ctx[3] === /*$user*/ ctx[4].name && create_if_block(ctx);

	pfp = new PFP({
			props: {
				icon: /*$profileData*/ ctx[2][/*member*/ ctx[0]]
				? /*$profileData*/ ctx[2][/*member*/ ctx[0]].pfp_data
				: -3,
				alt: "" + (/*member*/ ctx[0] + "'s profile picture"),
				online: /*$ulist*/ ctx[5].includes(/*member*/ ctx[0])
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div2 = element("div");
			div0 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			button = element("button");
			create_component(pfp.$$.fragment);
			t1 = space();
			div1 = element("div");
			h2 = element("h2");
			t2 = text(/*member*/ ctx[0]);
			attr_dev(div0, "class", "settings-controls s-b-eCKGcAk_zr");
			add_location(div0, file, 90, 2, 2203);
			attr_dev(button, "class", "pfp s-b-eCKGcAk_zr");
			add_location(button, file, 97, 2, 2344);
			attr_dev(h2, "class", "creator s-b-eCKGcAk_zr");
			add_location(h2, file, 112, 3, 2762);
			attr_dev(div1, "class", "creator s-b-eCKGcAk_zr");
			add_location(div1, file, 111, 2, 2737);
			attr_dev(div2, "class", "post-header s-b-eCKGcAk_zr");
			add_location(div2, file, 89, 1, 2175);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div0);
			if (if_block) if_block.m(div0, null);
			append_dev(div2, t0);
			append_dev(div2, button);
			mount_component(pfp, button, null);
			append_dev(div2, t1);
			append_dev(div2, div1);
			append_dev(div1, h2);
			append_dev(h2, t2);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*click_handler*/ ctx[6], false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*$chatOwner*/ ctx[3] === /*$user*/ ctx[4].name) {
				if (if_block) {
					
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(div0, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			const pfp_changes = {};

			if (dirty & /*$profileData, member*/ 5) pfp_changes.icon = /*$profileData*/ ctx[2][/*member*/ ctx[0]]
			? /*$profileData*/ ctx[2][/*member*/ ctx[0]].pfp_data
			: -3;

			if (dirty & /*member*/ 1) pfp_changes.alt = "" + (/*member*/ ctx[0] + "'s profile picture");
			if (dirty & /*$ulist, member*/ 33) pfp_changes.online = /*$ulist*/ ctx[5].includes(/*member*/ ctx[0]);
			pfp.$set(pfp_changes);
			if (!current || dirty & /*member*/ 1) set_data_dev(t2, /*member*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(pfp.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(pfp.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block) if_block.d();
			destroy_component(pfp);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(89:0) <Container>",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let container;
	let current;

	container = new Container({
			props: {
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(container.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(container, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const container_changes = {};

			if (dirty & /*$$scope, member, buttons, $profileData, $ulist, $chatOwner, $user*/ 319) {
				container_changes.$$scope = { dirty, ctx };
			}

			container.$set(container_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(container.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(container.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(container, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let $profileData;
	let $chatOwner;
	let $user;
	let $ulist;
	validate_store(profileData, 'profileData');
	component_subscribe($$self, profileData, $$value => $$invalidate(2, $profileData = $$value));
	validate_store(chatOwner, 'chatOwner');
	component_subscribe($$self, chatOwner, $$value => $$invalidate(3, $chatOwner = $$value));
	validate_store(user, 'user');
	component_subscribe($$self, user, $$value => $$invalidate(4, $user = $$value));
	validate_store(ulist, 'ulist');
	component_subscribe($$self, ulist, $$value => $$invalidate(5, $ulist = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Member', slots, []);
	let { member = "" } = $$props;
	let { buttons = true } = $$props;

	// TODO: make bridged tag a setting
	/**
 * Initialize this post's user profile - gets profile info from the cache or fetches it.
 */
	function initPostUser() {
		if (!member) return;

		/**
 * Fetch the user profile and store it in the cache.
 */
		const getProfile = async () => {
			let _profileData = $profileData;

			if (member === "Notification") {
				_profileData[member] = { pfp_data: 101 };
				profileData.set(_profileData);
				return;
			} else if (member === "Announcement") {
				_profileData[member] = { pfp_data: 102 };
				profileData.set(_profileData);
				return;
			} else if (member === "Server") {
				_profileData[member] = { pfp_data: 102 };
				profileData.set(_profileData);
				return;
			}

			_profileData[member] = { pfp_data: -1 };
			profileData.set(_profileData);

			fetch(`${apiUrl}/users/${member}`).then(response => response.json()).then(response => {
				// Ding dong! The data has arrived.
				_profileData[member] = response;

				console.log(response);
				profileData.set(_profileData);
			}).catch(e => {
				// Uh oh - something has gone wrong.
				console.log(e);

				_profileData[member] = {
					error: true,
					pfp_data: -2,
					temporary: true
				};

				profileData.set(_profileData);
			});
		};

		// Do we have a stored profile?
		const _profileData = $profileData;

		if (_profileData[member]) {
			// Reuse the cached data if the profile isn't temporary
			if (_profileData[member].temporary) {
				getProfile();
			}
		} else {
			// Get the profile!
			getProfile();
		}
	}

	;
	onMount(initPostUser);
	const writable_props = ['member', 'buttons'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Member> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		if (!buttons || member === "Notification" || member === "Announcement" || member === "Server") return;
		profileClicked.set(member);
		page.set("profile");
	};

	$$self.$$set = $$props => {
		if ('member' in $$props) $$invalidate(0, member = $$props.member);
		if ('buttons' in $$props) $$invalidate(1, buttons = $$props.buttons);
	};

	$$self.$capture_state = () => ({
		Container,
		PFP,
		profileData,
		profileClicked,
		postClicked,
		user,
		chatid,
		chatOwner,
		ulist,
		page,
		modalShown,
		modalPage,
		shiftHeld,
		clm,
		onMount,
		apiUrl,
		member,
		buttons,
		initPostUser,
		$profileData,
		$chatOwner,
		$user,
		$ulist
	});

	$$self.$inject_state = $$props => {
		if ('member' in $$props) $$invalidate(0, member = $$props.member);
		if ('buttons' in $$props) $$invalidate(1, buttons = $$props.buttons);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [member, buttons, $profileData, $chatOwner, $user, $ulist, click_handler];
}

class Member extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { member: 0, buttons: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Member",
			options,
			id: create_fragment.name
		});
	}

	get member() {
		throw new Error("<Member>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set member(value) {
		throw new Error("<Member>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get buttons() {
		throw new Error("<Member>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set buttons(value) {
		throw new Error("<Member>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

import * as ___SVELTE_HMR_HOT_API from '/node_modules/svelte-hmr/runtime/hot-api-esm.js';import { adapter as ___SVELTE_HMR_HOT_API_PROXY_ADAPTER } from '/node_modules/svelte-hmr/runtime/proxy-adapter-dom.js';if (import.meta && import.meta.hot) { if (false) import.meta.hot.accept();; Member = ___SVELTE_HMR_HOT_API.applyHmr({ m: import.meta, id: "C:/Users/Tnix/Desktop/Meower-Svelte-tnixandbloctans-finalfeatures/src/lib/Member.svelte", hotOptions: {"preserveLocalState":false,"noPreserveStateKey":["@hmr:reset","@!hmr"],"preserveAllLocalStateKey":"@hmr:keep-all","preserveLocalStateKey":"@hmr:keep","noReload":false,"optimistic":false,"acceptNamedExports":true,"acceptAccessors":true,"injectCss":false,"cssEjectDelay":100,"native":false,"importAdapterName":"___SVELTE_HMR_HOT_API_PROXY_ADAPTER","noOverlay":true,"allowLiveBinding":false}, Component: Member, ProxyAdapter: ___SVELTE_HMR_HOT_API_PROXY_ADAPTER, acceptable: true, preserveLocalState: false, emitCss: true, }); }
export default Member;


import "/src/lib/Member.svelte?svelte&type=style&lang.css";

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQUdRLFNBQVMsTUFBTSx5QkFBeUI7T0FDeEMsR0FBRyxNQUFNLG1CQUFtQjs7O0NBRTNCLFdBQVc7Q0FBRSxjQUFjO0NBQUUsV0FBVztDQUFFLElBQUk7Q0FBRSxNQUFNO0NBQUUsU0FBUztDQUFFLEtBQUs7Q0FBRSxRQUFRLElBQUksSUFBSTtDQUFFLFVBQVU7Q0FBRSxTQUFTO09BQU8sa0JBQWtCOztTQUMxSSxTQUFTLFFBQU8scUJBQXFCO09BQ3RDLFFBQVEsTUFBTSxxQkFBcUI7U0FFbEMsT0FBTyxRQUFPLFFBQVE7U0FDdEIsTUFBTSxRQUFPLFFBQVE7Ozs7Ozs7Ozs7Ozs7O0dBaUYxQixVQUVTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQkFITCxHQUFVLGtCQUFLLEdBQUssSUFBQyxJQUFJOzs7OzJCQWV2QixHQUFZLGVBQUMsR0FBTTt1QkFBSSxHQUFZLGVBQUMsR0FBTSxLQUFFLFFBQVE7T0FBSSxDQUFDOzBCQUN6RCxHQUFNO3VCQUNKLEdBQU0sSUFBQyxRQUFRLFlBQUMsR0FBTTs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFJVixHQUFNOzs7Ozs7Ozs7Ozs7O0dBdkI3QixVQXlCSztHQXhCSixVQU1LOzs7R0FDTCxVQWFROzs7R0FDUixVQUVLO0dBREosVUFBZ0M7Ozs7Ozs7Ozs7c0JBckIzQixHQUFVLGtCQUFLLEdBQUssSUFBQyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7K0VBZXZCLEdBQVksZUFBQyxHQUFNO3NCQUFJLEdBQVksZUFBQyxHQUFNLEtBQUUsUUFBUTtNQUFJLENBQUM7O2dFQUN6RCxHQUFNO3NFQUNKLEdBQU0sSUFBQyxRQUFRLFlBQUMsR0FBTTs7cUVBSVYsR0FBTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQXBHbEIsTUFBTSxHQUFHLEVBQUU7T0FDWCxPQUFPLEdBQUcsSUFBSTs7Ozs7O1VBT2hCLFlBQVk7T0FDZixNQUFNOzs7OztRQUtMLFVBQVU7T0FDWCxZQUFZLEdBQUcsWUFBWTs7T0FFM0IsTUFBTSxLQUFLLGNBQWM7SUFDNUIsWUFBWSxDQUFDLE1BQU0sTUFDbEIsUUFBUSxFQUFFLEdBQUE7SUFFWCxXQUFXLENBQUMsR0FBRyxDQUFDLFlBQVk7O2NBRWxCLE1BQU0sS0FBSyxjQUFjO0lBQ25DLFlBQVksQ0FBQyxNQUFNLE1BQ2xCLFFBQVEsRUFBRSxHQUFBO0lBRVgsV0FBVyxDQUFDLEdBQUcsQ0FBQyxZQUFZOztjQUVsQixNQUFNLEtBQUssUUFBUTtJQUM3QixZQUFZLENBQUMsTUFBTSxNQUNsQixRQUFRLEVBQUUsR0FBQTtJQUVYLFdBQVcsQ0FBQyxHQUFHLENBQUMsWUFBWTs7OztHQUk3QixZQUFZLENBQUMsTUFBTSxNQUNsQixRQUFRLEdBQUcsQ0FBQztHQUViLFdBQVcsQ0FBQyxHQUFHLENBQUMsWUFBWTs7R0FFNUIsS0FBSyxJQUFJLE1BQU0sVUFBVSxNQUFNLElBQzlCLElBQUksQ0FBRSxRQUFRLElBQUssUUFBUSxDQUFDLElBQUksSUFDaEMsSUFBSSxDQUFDLFFBQVE7O0lBRWIsWUFBWSxDQUFDLE1BQU0sSUFBSSxRQUFROztJQUMvQixPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVE7SUFDcEIsV0FBVyxDQUFDLEdBQUcsQ0FBQyxZQUFZO01BQzFCLEtBQUssQ0FBQyxDQUFDOztJQUVULE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQzs7SUFDYixZQUFZLENBQUMsTUFBTTtLQUNsQixLQUFLLEVBQUUsSUFBSTtLQUNYLFFBQVEsR0FBRyxDQUFDO0tBQ1osU0FBUyxFQUFFLElBQUk7OztJQUVoQixXQUFXLENBQUMsR0FBRyxDQUFDLFlBQVk7Ozs7O1FBS3hCLFlBQVksR0FBRyxZQUFZOztNQUM3QixZQUFZLENBQUMsTUFBTTs7T0FFbEIsWUFBWSxDQUFDLE1BQU0sRUFBRSxTQUFTO0lBQ2pDLFVBQVU7Ozs7R0FJWCxVQUFVOzs7OztDQUdaLE9BQU8sQ0FBQyxZQUFZOzs7Ozs7OztPQWVaLE9BQU8sSUFBSSxNQUFNLEtBQUssY0FBYyxJQUFJLE1BQU0sS0FBSyxjQUFjLElBQUksTUFBTSxLQUFLLFFBQVE7RUFDN0YsY0FBYyxDQUFDLEdBQUcsQ0FBQyxNQUFNO0VBQ3pCLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTWVtYmVyLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8IS0tIEEgcG9zdC4gUHJvZmlsZSBwaWN0dXJlcyBub3QgYXBwZWFyaW5nIHdoaWxlIG5vdCBsb2dnZWQgaW4gaXMgaW50ZW50aW9uYWwuIC0tPlxuXG48c2NyaXB0PlxuXHRpbXBvcnQgQ29udGFpbmVyIGZyb20gXCIuLi9saWIvQ29udGFpbmVyLnN2ZWx0ZVwiO1xuXHRpbXBvcnQgUEZQIGZyb20gXCIuLi9saWIvUEZQLnN2ZWx0ZVwiO1xuXG5cdGltcG9ydCB7cHJvZmlsZURhdGEsIHByb2ZpbGVDbGlja2VkLCBwb3N0Q2xpY2tlZCwgdXNlciwgY2hhdGlkLCBjaGF0T3duZXIsIHVsaXN0LCBtYWluUGFnZSBhcyBwYWdlLCBtb2RhbFNob3duLCBtb2RhbFBhZ2V9IGZyb20gXCIuLi9saWIvc3RvcmVzLmpzXCI7XG5cdGltcG9ydCB7c2hpZnRIZWxkfSBmcm9tIFwiLi4vbGliL2tleURldGVjdC5qc1wiO1xuXHRpbXBvcnQgKiBhcyBjbG0gZnJvbSBcIi4uL2xpYi9jbG1hbmFnZXIuanNcIjtcblxuXHRpbXBvcnQge29uTW91bnR9IGZyb20gXCJzdmVsdGVcIjtcblx0aW1wb3J0IHthcGlVcmx9IGZyb20gXCIuL3VybHNcIjtcblx0ZXhwb3J0IGxldCBtZW1iZXIgPSBcIlwiO1xuXHRleHBvcnQgbGV0IGJ1dHRvbnMgPSB0cnVlO1xuXG5cdC8vIFRPRE86IG1ha2UgYnJpZGdlZCB0YWcgYSBzZXR0aW5nXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhpcyBwb3N0J3MgdXNlciBwcm9maWxlIC0gZ2V0cyBwcm9maWxlIGluZm8gZnJvbSB0aGUgY2FjaGUgb3IgZmV0Y2hlcyBpdC5cblx0ICovXG5cdGZ1bmN0aW9uIGluaXRQb3N0VXNlcigpIHtcblx0XHRpZiAoIW1lbWJlcikgcmV0dXJuO1xuXG5cdFx0LyoqXG5cdFx0ICogRmV0Y2ggdGhlIHVzZXIgcHJvZmlsZSBhbmQgc3RvcmUgaXQgaW4gdGhlIGNhY2hlLlxuXHRcdCAqL1xuXHRcdGNvbnN0IGdldFByb2ZpbGUgPSBhc3luYyAoKSA9PiB7XG5cdFx0XHRsZXQgX3Byb2ZpbGVEYXRhID0gJHByb2ZpbGVEYXRhO1xuXG5cdFx0XHRpZiAobWVtYmVyID09PSBcIk5vdGlmaWNhdGlvblwiKSB7XG5cdFx0XHRcdF9wcm9maWxlRGF0YVttZW1iZXJdID0ge1xuXHRcdFx0XHRcdHBmcF9kYXRhOiAxMDFcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9maWxlRGF0YS5zZXQoX3Byb2ZpbGVEYXRhKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIGlmIChtZW1iZXIgPT09IFwiQW5ub3VuY2VtZW50XCIpIHtcblx0XHRcdFx0X3Byb2ZpbGVEYXRhW21lbWJlcl0gPSB7XG5cdFx0XHRcdFx0cGZwX2RhdGE6IDEwMlxuXHRcdFx0XHR9XG5cdFx0XHRcdHByb2ZpbGVEYXRhLnNldChfcHJvZmlsZURhdGEpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IGVsc2UgaWYgKG1lbWJlciA9PT0gXCJTZXJ2ZXJcIikge1xuXHRcdFx0XHRfcHJvZmlsZURhdGFbbWVtYmVyXSA9IHtcblx0XHRcdFx0XHRwZnBfZGF0YTogMTAyXG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvZmlsZURhdGEuc2V0KF9wcm9maWxlRGF0YSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0X3Byb2ZpbGVEYXRhW21lbWJlcl0gPSB7XG5cdFx0XHRcdHBmcF9kYXRhOiAtMSxcblx0XHRcdH07XG5cdFx0XHRwcm9maWxlRGF0YS5zZXQoX3Byb2ZpbGVEYXRhKTtcblxuXHRcdFx0ZmV0Y2goYCR7YXBpVXJsfS91c2Vycy8ke21lbWJlcn1gKVxuXHRcdFx0LnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG5cdFx0XHQudGhlbihyZXNwb25zZSA9PiB7XG5cdFx0XHRcdC8vIERpbmcgZG9uZyEgVGhlIGRhdGEgaGFzIGFycml2ZWQuXG5cdFx0XHRcdF9wcm9maWxlRGF0YVttZW1iZXJdID0gcmVzcG9uc2U7XG5cdFx0XHRcdGNvbnNvbGUubG9nKHJlc3BvbnNlKVxuXHRcdFx0XHRwcm9maWxlRGF0YS5zZXQoX3Byb2ZpbGVEYXRhKTtcblx0XHRcdH0pLmNhdGNoKGUgPT4ge1xuXHRcdFx0XHQvLyBVaCBvaCAtIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZy5cblx0XHRcdFx0Y29uc29sZS5sb2coZSlcblx0XHRcdFx0X3Byb2ZpbGVEYXRhW21lbWJlcl0gPSB7XG5cdFx0XHRcdFx0ZXJyb3I6IHRydWUsXG5cdFx0XHRcdFx0cGZwX2RhdGE6IC0yLFxuXHRcdFx0XHRcdHRlbXBvcmFyeTogdHJ1ZSxcblx0XHRcdFx0fTtcblx0XHRcdFx0cHJvZmlsZURhdGEuc2V0KF9wcm9maWxlRGF0YSk7XG5cdFx0XHR9KVxuXHRcdH1cblxuXHRcdC8vIERvIHdlIGhhdmUgYSBzdG9yZWQgcHJvZmlsZT9cblx0XHRjb25zdCBfcHJvZmlsZURhdGEgPSAkcHJvZmlsZURhdGE7XG5cdFx0aWYgKF9wcm9maWxlRGF0YVttZW1iZXJdKSB7XG5cdFx0XHQvLyBSZXVzZSB0aGUgY2FjaGVkIGRhdGEgaWYgdGhlIHByb2ZpbGUgaXNuJ3QgdGVtcG9yYXJ5XG5cdFx0XHRpZiAoX3Byb2ZpbGVEYXRhW21lbWJlcl0udGVtcG9yYXJ5KSB7XG5cdFx0XHRcdGdldFByb2ZpbGUoKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gR2V0IHRoZSBwcm9maWxlIVxuXHRcdFx0Z2V0UHJvZmlsZSgpO1xuXHRcdH1cblx0fTtcblx0b25Nb3VudChpbml0UG9zdFVzZXIpO1xuPC9zY3JpcHQ+XG5cbjxDb250YWluZXI+XG5cdDxkaXYgY2xhc3M9XCJwb3N0LWhlYWRlclwiPlxuXHRcdDxkaXYgY2xhc3M9XCJzZXR0aW5ncy1jb250cm9sc1wiPlxuXHRcdFx0eyNpZiAkY2hhdE93bmVyID09PSAkdXNlci5uYW1lfVxuXHRcdFx0XHQ8YnV0dG9uIFxuXHRcdFx0XHRcdGNsYXNzPVwiY2lyY2xlIGNsb3NlXCJcblx0XHRcdFx0PjwvYnV0dG9uPlxuXHRcdFx0ey9pZn1cblx0XHQ8L2Rpdj5cblx0XHQ8YnV0dG9uXG5cdFx0XHRjbGFzcz1cInBmcFwiIFxuXHRcdFx0b246Y2xpY2s9eygpPT57XG5cdFx0XHRcdGlmICghYnV0dG9ucyB8fCBtZW1iZXIgPT09IFwiTm90aWZpY2F0aW9uXCIgfHwgbWVtYmVyID09PSBcIkFubm91bmNlbWVudFwiIHx8IG1lbWJlciA9PT0gXCJTZXJ2ZXJcIikgcmV0dXJuO1xuXHRcdFx0XHRwcm9maWxlQ2xpY2tlZC5zZXQobWVtYmVyKTtcblx0XHRcdFx0cGFnZS5zZXQoXCJwcm9maWxlXCIpO1xuXHRcdFx0fX1cblx0XHQ+XG5cdFx0XHQ8UEZQXG5cdFx0XHRcdGljb249eyRwcm9maWxlRGF0YVttZW1iZXJdID8gJHByb2ZpbGVEYXRhW21lbWJlcl0ucGZwX2RhdGEgOiAtM31cblx0XHRcdFx0YWx0PVwie21lbWJlcn0ncyBwcm9maWxlIHBpY3R1cmVcIlxuXHRcdFx0XHRvbmxpbmU9eyR1bGlzdC5pbmNsdWRlcyhtZW1iZXIpfVxuXHRcdFx0PjwvUEZQPlxuXHRcdDwvYnV0dG9uPlxuXHRcdDxkaXYgY2xhc3M9XCJjcmVhdG9yXCI+XG5cdFx0XHQ8aDIgY2xhc3M9XCJjcmVhdG9yXCI+e21lbWJlcn08L2gyPlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cbjwvQ29udGFpbmVyPlxuXG48c3R5bGU+XG5cdC5wZnAge1xuXHRcdG1hcmdpbi1yaWdodDogMC4yZW07XG5cdFx0cGFkZGluZzogMDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0YmFja2dyb3VuZDogbm9uZSAhaW1wb3J0YW50O1xuXHRcdGNvbG9yOiBpbmhlcml0O1xuXHR9XG5cdC5wb3N0LWhlYWRlciB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRhbGlnbi1pdGVtczogY2VudGVyO1xuXHRcdGZsZXgtd3JhcDogd3JhcDtcblx0fVxuXHQuY3JlYXRvciB7XG5cdFx0ZGlzcGxheTogaW5saW5lO1xuXHRcdG1heC13aWR0aDogMTAwJTtcblx0XHRtYXJnaW4tbGVmdDogMC41ZW07XG5cdH1cblx0LmNyZWF0b3IgaDIge1xuXHRcdGRpc3BsYXk6IGJsb2NrO1xuXHRcdGZvbnQtc2l6ZTogMjAwJTtcblx0XHRtYXJnaW46IDA7XG5cdH1cblx0LnBmcDpob3Zlcjpub3QoOmFjdGl2ZSkgOmdsb2JhbCgucGZwKSwgLnBmcDpmb2N1cy12aXNpYmxlIDpnbG9iYWwoLnBmcCkge1xuXHRcdHRyYW5zZm9ybTogc2NhbGUoMS4xKTtcblx0fVxuXHQuc2V0dGluZ3MtY29udHJvbHMge1xuXHRcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcblx0XHR0b3A6IDAuMjVlbTtcblx0XHRyaWdodDogMC4yNWVtO1xuXHR9XG5cdGJ1dHRvbi5jaXJjbGUge1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHRtYXJnaW46IDA7XG5cdFx0bWFyZ2luLWxlZnQ6IDAuMTI1ZW07XG5cdH1cbjwvc3R5bGU+XG4iXX0=